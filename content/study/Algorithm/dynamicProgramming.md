---
title: "Dynamic Programming"
date: 2023-01-31
draft: false
category: [study]
subcategories: [Algorithm]
tags: [Algorithm]
---

`다이나믹 프로그래밍(동적 프로그래밍)`은 하나의 문제를 단 한 번만 풀도록 하는 알고리즘이다.

<!--more-->

상당수의 분할정복 기법은 동일한 문제를 다시 푼다는 단점을 가지고 있다. 하지만 다이나믹 프로그래밍은 단 한 번만 풀도록 하는 알고리즘이다.

피보나치를 예로들어보겠다. 피보나치의 경우 `f(n) = f(n-1) + f(n-2)`라는 재귀적인 사고로 아주 간단하게 풀어나갈 수 있다. 하지만 재귀적인 사고는 여러번의 중복호출이 존재한다.

![](/images/study/Algorithms/dynamicProgramming/1.jpg)

이렇게 중복호출된 피보나치 함수는 엄청난 비효율을 초래할 수 있다.

피보나치 수열을 `다이나믹 프로그래밍(동적 프로그래밍)`으로 풀게 되었을때는 `f[n] = f[n-1] + f[n-2]`의 개념으로 문제를 풀 수있다.

```c
fibonacci(n){
    f[1] = 1;
    f[2] = 1;

    for(int i = 3; i < n; i++){
        f[i] = f[i-1] + f[i-2];
    }
    return f[n];
}
```

이렇게 위의 코드를 사용하면 재귀처럼 중복호출 없이 사용이 가능하다.

이외에 행렬경로 문제에 대해 살펴보겠다.

![](/images/study/Algorithms/dynamicProgramming/2.jpg)

양수로 이루어진 n x n행렬이 주어진다. 행렬의 왼쪽 위에서 시작해 한 칸씩 이동해 오른쪽 아래까지 도달한다. 이 과정에서 방문한 칸에 있는 수들을 더한 값이 이 경로의 합이다. 이동규칙은 다음과 같다.

1. 오른쪽이나 아래쪽으로만 이동할 수 있다.
2. 왼쪽, 위쪽, 대각선 이동은 허용하지 않는다.

경로의 합중 가장 큰 값을 찾아야 하는 문제인데, 부분 또한 재귀로 풀게되면 피보나치와 동일하게 여러번의 중복호출이 존재한다. 하지만 다이나믹 프로그래밍으로 문제를 풀게 된다면 아주 간단하게 문제를 풀 수 있다.

```c
int matrixPath(int n) {

    c[0][0] = arr[0][0];

    for (int i = 1; i < n; i++)
        c[i][0] = arr[i][0] + c[i - 1][0];
    for (int i = 1; i < n; i++)
        c[0][i] = arr[0][i] + c[0][i - 1];
    for (int i = 1; i < n; i++) {
        for (int j = 1; j < n; j++)
            c[i][j] = arr[i][j] + max(c[i - 1][j], c[i][j - 1]);
    }
    return c[n - 1][n - 1];
}
```

c배열이 경로의 합들이 저장될 배열이고 arr배열이 행렬의 가중치가 저장되어 있는 배열이다. 오른쪽과 아래쪽으로만 이동할 수 있기때문에, 현재 위치에서 왼쪽과 위쪽중 가장 큰 경로합과 현재 위치의 가중치를 더해주면 된다. 첫번째와 두번째 for문은 각각 노랑과 주황 부분의 경로합을 결정해준다. 이후 초록 부분은 세번째 for문 중첩을 이용해 왼쪽과 위중 가중치가 더 큰값에 더하기를 해준다. 이렇게 구해진 경로가 회색 경로이다.